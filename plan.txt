[command]/home/runner/work/_temp/8036a8fe-67be-468f-9995-c1a6cdd9768d/terraform-bin plan -no-color -input=false
module.lambda.local_file.lambda_code: Refreshing state... [id=7fa3ea14c87c4a1020900d8a22933efada1654f1]
module.lambda.null_resource.install_dependencies: Refreshing state... [id=6486892172533290355]
random_string.suffix: Refreshing state... [id=qpjdoqdo]
module.lambda.aws_lambda_layer_version.dependencies: Refreshing state... [id=arn:aws:lambda:ap-south-1:199570228070:layer:img-processor-dev-image-processor-qpjdoqdo-dependencies:1]
module.sns.aws_sns_topic.notifications: Refreshing state... [id=arn:aws:sns:ap-south-1:199570228070:img-processor-dev-notifications-qpjdoqdo]
module.lambda.aws_iam_role.lambda_role: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role]
module.s3_buckets.aws_s3_bucket.processed: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]
module.s3_buckets.aws_s3_bucket.source: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]
module.sns.aws_sns_topic_policy.default: Refreshing state... [id=arn:aws:sns:ap-south-1:199570228070:img-processor-dev-notifications-qpjdoqdo]
module.lambda.aws_iam_policy.lambda_sns_policy: Refreshing state... [id=arn:aws:iam::199570228070:policy/img-processor-dev-image-processor-qpjdoqdo-sns-policy]
module.sns.aws_sns_topic_subscription.email_subscriptions[0]: Refreshing state... [id=arn:aws:sns:ap-south-1:199570228070:img-processor-dev-notifications-qpjdoqdo:27b0c78d-7b47-4d61-b66c-b60501bbcb18]
module.lambda.aws_iam_role_policy_attachment.lambda_sns_policy_attachment: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role-20250605131832827500000001]
module.s3_buckets.aws_s3_bucket_public_access_block.source_public_access_block: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]
module.s3_buckets.aws_s3_bucket_versioning.source_versioning: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]
module.s3_buckets.aws_s3_bucket_server_side_encryption_configuration.source_encryption: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]
module.s3_buckets.aws_s3_bucket_cors_configuration.source_cors: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]
module.s3_buckets.aws_s3_bucket_public_access_block.processed_public_access_block: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]
module.s3_buckets.aws_s3_bucket_server_side_encryption_configuration.processed_encryption: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]
module.s3_buckets.aws_s3_bucket_versioning.processed_versioning: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]
module.lambda.aws_iam_policy.lambda_s3_policy: Refreshing state... [id=arn:aws:iam::199570228070:policy/img-processor-dev-image-processor-qpjdoqdo-s3-policy]
module.lambda.aws_lambda_function.image_processor: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo]
module.lambda.aws_iam_role_policy_attachment.lambda_s3_policy_attachment: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role-20250605131836551400000002]
module.lambda.aws_lambda_permission.allow_s3: Refreshing state... [id=AllowExecutionFromS3]
module.lambda.aws_cloudwatch_log_group.lambda_logs: Refreshing state... [id=/aws/lambda/img-processor-dev-image-processor-qpjdoqdo]
aws_s3_bucket_notification.bucket_notification: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]
module.lambda.aws_iam_policy.lambda_logs_policy: Refreshing state... [id=arn:aws:iam::199570228070:policy/img-processor-dev-image-processor-qpjdoqdo-logs-policy]
module.lambda.aws_iam_role_policy_attachment.lambda_logs_policy_attachment: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role-20250605131857002400000004]

Note: Objects have changed outside of Terraform

Terraform detected the following changes made outside of Terraform since the
last "terraform apply" which may have affected this plan:

  # module.lambda.local_file.lambda_code has been deleted
  - resource "local_file" "lambda_code" {
      - content              = <<-EOT
            // Image processing Lambda function
            const AWS = require('aws-sdk');
            const sharp = require('sharp');
                
            const s3 = new AWS.S3();
            const sns = new AWS.SNS();
                
            // Image sizes for resizing
            const sizes = [
              { width: 100, height: 100, suffix: 'thumbnail' },
              { width: 800, height: null, suffix: 'medium' },
              { width: 1200, height: null, suffix: 'large' }
            ];
                
            exports.handler = async (event) => {
              try {
                // Get the object from the event
                const sourceBucket = event.Records[0].s3.bucket.name;
                const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));
                    
                // Skip processing if the file is not in the uploads folder or not an image
                if (!key.startsWith('uploads/') || !key.match(/\.(jpg|jpeg|png|gif)$/i)) {
                  console.log('Skipping non-image file:', key);
                  return;
                }
                    
                // Get the image from S3
                const params = {
                  Bucket: sourceBucket,
                  Key: key
                };
                    
                const { Body: imageBody } = await s3.getObject(params).promise();
                    
                // Original filename without path
                const filename = key.split('/').pop();
                const fileNameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));
                const extension = filename.substring(filename.lastIndexOf('.') + 1);
                    
                // Process image for each size
                const resizePromises = sizes.map(async (size) => {
                  const resizedImage = await sharp(imageBody)
                    .resize(size.width, size.height)
                    .toBuffer();
                      
                  const destKey = "processed/" + fileNameWithoutExt + "-" + size.suffix + "." + extension;
                      
                  await s3.putObject({
                    Bucket: process.env.target_bucket,
                    Key: destKey,
                    Body: resizedImage,
                    ContentType: "image/" + (extension === "jpg" ? "jpeg" : extension)
                  }).promise();
                      
                  return destKey;
                });
                    
                const resizedImageKeys = await Promise.all(resizePromises);
                    
                // Send notification
                await sns.publish({
                  TopicArn: process.env.SNS_TOPIC_ARN,
                  Subject: 'Image Processing Completed',
                  Message: JSON.stringify({
                    originalImage: key,
                    processedImages: resizedImageKeys,
                    timestamp: new Date().toISOString()
                  })
                }).promise();
                    
                console.log('Image processing completed successfully');
                return {
                  statusCode: 200,
                  body: JSON.stringify({
                    message: 'Image processing completed successfully',
                    originalImage: key,
                    processedImages: resizedImageKeys
                  })
                };
                    
              } catch (error) {
                console.error('Error processing image:', error);
                    
                // Send error notification
                await sns.publish({
                  TopicArn: process.env.SNS_TOPIC_ARN,
                  Subject: 'Image Processing Error',
                  Message: JSON.stringify({
                    error: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString()
                  })
                }).promise();
                    
                return {
                  statusCode: 500,
                  body: JSON.stringify({
                    message: 'Error processing image',
                    error: error.message
                  })
                };
              }
            };
        EOT -> null
        id                   = "7fa3ea14c87c4a1020900d8a22933efada1654f1"
        # (9 unchanged attributes hidden)
    }


Unless you have made equivalent changes to your configuration, or ignored the
relevant attributes using ignore_changes, the following plan may include
actions to undo or respond to these changes.

─────────────────────────────────────────────────────────────────────────────

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create
  ~ update in-place
 <= read (data resources)

Terraform will perform the following actions:

  # module.lambda.data.archive_file.lambda_zip will be read during apply
  # (depends on a resource or a module with changes pending)
 <= data "archive_file" "lambda_zip" {
      + id                  = (known after apply)
      + output_base64sha256 = (known after apply)
      + output_base64sha512 = (known after apply)
      + output_md5          = (known after apply)
      + output_path         = "modules/lambda/lambda_function.zip"
      + output_sha          = (known after apply)
      + output_sha256       = (known after apply)
      + output_sha512       = (known after apply)
      + output_size         = (known after apply)
      + type                = "zip"

      + source {
          + content  = <<-EOT
                // Image processing Lambda function
                const AWS = require('aws-sdk');
                const sharp = require('sharp');
                    
                const s3 = new AWS.S3();
                const sns = new AWS.SNS();
                    
                // Image sizes for resizing
                const sizes = [
                  { width: 100, height: 100, suffix: 'thumbnail' },
                  { width: 800, height: null, suffix: 'medium' },
                  { width: 1200, height: null, suffix: 'large' }
                ];
                    
                exports.handler = async (event) => {
                  try {
                    // Get the object from the event
                    const sourceBucket = event.Records[0].s3.bucket.name;
                    const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));
                        
                    // Skip processing if the file is not in the uploads folder or not an image
                    if (!key.startsWith('uploads/') || !key.match(/\.(jpg|jpeg|png|gif)$/i)) {
                      console.log('Skipping non-image file:', key);
                      return;
                    }
                        
                    // Get the image from S3
                    const params = {
                      Bucket: sourceBucket,
                      Key: key
                    };
                        
                    const { Body: imageBody } = await s3.getObject(params).promise();
                        
                    // Original filename without path
                    const filename = key.split('/').pop();
                    const fileNameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));
                    const extension = filename.substring(filename.lastIndexOf('.') + 1);
                        
                    // Process image for each size
                    const resizePromises = sizes.map(async (size) => {
                      const resizedImage = await sharp(imageBody)
                        .resize(size.width, size.height)
                        .toBuffer();
                          
                      const destKey = "processed/" + fileNameWithoutExt + "-" + size.suffix + "." + extension;
                          
                      await s3.putObject({
                        Bucket: process.env.target_bucket,
                        Key: destKey,
                        Body: resizedImage,
                        ContentType: "image/" + (extension === "jpg" ? "jpeg" : extension)
                      }).promise();
                          
                      return destKey;
                    });
                        
                    const resizedImageKeys = await Promise.all(resizePromises);
                        
                    // Send notification
                    await sns.publish({
                      TopicArn: process.env.SNS_TOPIC_ARN,
                      Subject: 'Image Processing Completed',
                      Message: JSON.stringify({
                        originalImage: key,
                        processedImages: resizedImageKeys,
                        timestamp: new Date().toISOString()
                      })
                    }).promise();
                        
                    console.log('Image processing completed successfully');
                    return {
                      statusCode: 200,
                      body: JSON.stringify({
                        message: 'Image processing completed successfully',
                        originalImage: key,
                        processedImages: resizedImageKeys
                      })
                    };
                        
                  } catch (error) {
                    console.error('Error processing image:', error);
                        
                    // Send error notification
                    await sns.publish({
                      TopicArn: process.env.SNS_TOPIC_ARN,
                      Subject: 'Image Processing Error',
                      Message: JSON.stringify({
                        error: error.message,
                        stack: error.stack,
                        timestamp: new Date().toISOString()
                      })
                    }).promise();
                        
                    return {
                      statusCode: 500,
                      body: JSON.stringify({
                        message: 'Error processing image',
                        error: error.message
                      })
                    };
                  }
                };
            EOT
          + filename = "index.js"
        }
    }

  # module.lambda.aws_lambda_function.image_processor will be updated in-place
  ~ resource "aws_lambda_function" "image_processor" {
        id                             = "img-processor-dev-image-processor-qpjdoqdo"
      ~ last_modified                  = "2025-06-05T13:18:47.032+0000" -> (known after apply)
      ~ source_code_hash               = "fEV+BBiFC8q+pevnzYvi+TwgJPat0IQVmu08lH/uZVg=" -> (known after apply)
        tags                           = {
            "Environment" = "dev"
            "Name"        = "img-processor-dev-image-processor-qpjdoqdo"
        }
        # (27 unchanged attributes hidden)

        # (4 unchanged blocks hidden)
    }

  # module.lambda.local_file.lambda_code will be created
  + resource "local_file" "lambda_code" {
      + content              = <<-EOT
            // Image processing Lambda function
            const AWS = require('aws-sdk');
            const sharp = require('sharp');
                
            const s3 = new AWS.S3();
            const sns = new AWS.SNS();
                
            // Image sizes for resizing
            const sizes = [
              { width: 100, height: 100, suffix: 'thumbnail' },
              { width: 800, height: null, suffix: 'medium' },
              { width: 1200, height: null, suffix: 'large' }
            ];
                
            exports.handler = async (event) => {
              try {
                // Get the object from the event
                const sourceBucket = event.Records[0].s3.bucket.name;
                const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));
                    
                // Skip processing if the file is not in the uploads folder or not an image
                if (!key.startsWith('uploads/') || !key.match(/\.(jpg|jpeg|png|gif)$/i)) {
                  console.log('Skipping non-image file:', key);
                  return;
                }
                    
                // Get the image from S3
                const params = {
                  Bucket: sourceBucket,
                  Key: key
                };
                    
                const { Body: imageBody } = await s3.getObject(params).promise();
                    
                // Original filename without path
                const filename = key.split('/').pop();
                const fileNameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));
                const extension = filename.substring(filename.lastIndexOf('.') + 1);
                    
                // Process image for each size
                const resizePromises = sizes.map(async (size) => {
                  const resizedImage = await sharp(imageBody)
                    .resize(size.width, size.height)
                    .toBuffer();
                      
                  const destKey = "processed/" + fileNameWithoutExt + "-" + size.suffix + "." + extension;
                      
                  await s3.putObject({
                    Bucket: process.env.target_bucket,
                    Key: destKey,
                    Body: resizedImage,
                    ContentType: "image/" + (extension === "jpg" ? "jpeg" : extension)
                  }).promise();
                      
                  return destKey;
                });
                    
                const resizedImageKeys = await Promise.all(resizePromises);
                    
                // Send notification
                await sns.publish({
                  TopicArn: process.env.SNS_TOPIC_ARN,
                  Subject: 'Image Processing Completed',
                  Message: JSON.stringify({
                    originalImage: key,
                    processedImages: resizedImageKeys,
                    timestamp: new Date().toISOString()
                  })
                }).promise();
                    
                console.log('Image processing completed successfully');
                return {
                  statusCode: 200,
                  body: JSON.stringify({
                    message: 'Image processing completed successfully',
                    originalImage: key,
                    processedImages: resizedImageKeys
                  })
                };
                    
              } catch (error) {
                console.error('Error processing image:', error);
                    
                // Send error notification
                await sns.publish({
                  TopicArn: process.env.SNS_TOPIC_ARN,
                  Subject: 'Image Processing Error',
                  Message: JSON.stringify({
                    error: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString()
                  })
                }).promise();
                    
                return {
                  statusCode: 500,
                  body: JSON.stringify({
                    message: 'Error processing image',
                    error: error.message
                  })
                };
              }
            };
        EOT
      + content_base64sha256 = (known after apply)
      + content_base64sha512 = (known after apply)
      + content_md5          = (known after apply)
      + content_sha1         = (known after apply)
      + content_sha256       = (known after apply)
      + content_sha512       = (known after apply)
      + directory_permission = "0777"
      + file_permission      = "0777"
      + filename             = "modules/lambda/src/index.js"
      + id                   = (known after apply)
    }

Plan: 1 to add, 1 to change, 0 to destroy.

─────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
Releasing state lock. This may take a few moments...
::debug::Terraform exited with code 0.
::debug::stdout: module.lambda.local_file.lambda_code: Refreshing state... [id=7fa3ea14c87c4a1020900d8a22933efada1654f1]%0Amodule.lambda.null_resource.install_dependencies: Refreshing state... [id=6486892172533290355]%0Arandom_string.suffix: Refreshing state... [id=qpjdoqdo]%0Amodule.lambda.aws_lambda_layer_version.dependencies: Refreshing state... [id=arn:aws:lambda:ap-south-1:199570228070:layer:img-processor-dev-image-processor-qpjdoqdo-dependencies:1]%0Amodule.sns.aws_sns_topic.notifications: Refreshing state... [id=arn:aws:sns:ap-south-1:199570228070:img-processor-dev-notifications-qpjdoqdo]%0Amodule.lambda.aws_iam_role.lambda_role: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role]%0Amodule.s3_buckets.aws_s3_bucket.processed: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]%0Amodule.s3_buckets.aws_s3_bucket.source: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]%0Amodule.sns.aws_sns_topic_policy.default: Refreshing state... [id=arn:aws:sns:ap-south-1:199570228070:img-processor-dev-notifications-qpjdoqdo]%0Amodule.lambda.aws_iam_policy.lambda_sns_policy: Refreshing state... [id=arn:aws:iam::199570228070:policy/img-processor-dev-image-processor-qpjdoqdo-sns-policy]%0Amodule.sns.aws_sns_topic_subscription.email_subscriptions[0]: Refreshing state... [id=arn:aws:sns:ap-south-1:199570228070:img-processor-dev-notifications-qpjdoqdo:27b0c78d-7b47-4d61-b66c-b60501bbcb18]%0Amodule.lambda.aws_iam_role_policy_attachment.lambda_sns_policy_attachment: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role-20250605131832827500000001]%0Amodule.s3_buckets.aws_s3_bucket_public_access_block.source_public_access_block: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]%0Amodule.s3_buckets.aws_s3_bucket_versioning.source_versioning: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]%0Amodule.s3_buckets.aws_s3_bucket_server_side_encryption_configuration.source_encryption: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]%0Amodule.s3_buckets.aws_s3_bucket_cors_configuration.source_cors: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]%0Amodule.s3_buckets.aws_s3_bucket_public_access_block.processed_public_access_block: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]%0Amodule.s3_buckets.aws_s3_bucket_server_side_encryption_configuration.processed_encryption: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]%0Amodule.s3_buckets.aws_s3_bucket_versioning.processed_versioning: Refreshing state... [id=img-processor-dev-processed-qpjdoqdo]%0Amodule.lambda.aws_iam_policy.lambda_s3_policy: Refreshing state... [id=arn:aws:iam::199570228070:policy/img-processor-dev-image-processor-qpjdoqdo-s3-policy]%0Amodule.lambda.aws_lambda_function.image_processor: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo]%0Amodule.lambda.aws_iam_role_policy_attachment.lambda_s3_policy_attachment: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role-20250605131836551400000002]%0Amodule.lambda.aws_lambda_permission.allow_s3: Refreshing state... [id=AllowExecutionFromS3]%0Amodule.lambda.aws_cloudwatch_log_group.lambda_logs: Refreshing state... [id=/aws/lambda/img-processor-dev-image-processor-qpjdoqdo]%0Aaws_s3_bucket_notification.bucket_notification: Refreshing state... [id=img-processor-dev-source-qpjdoqdo]%0Amodule.lambda.aws_iam_policy.lambda_logs_policy: Refreshing state... [id=arn:aws:iam::199570228070:policy/img-processor-dev-image-processor-qpjdoqdo-logs-policy]%0Amodule.lambda.aws_iam_role_policy_attachment.lambda_logs_policy_attachment: Refreshing state... [id=img-processor-dev-image-processor-qpjdoqdo-role-20250605131857002400000004]%0A%0ANote: Objects have changed outside of Terraform%0A%0ATerraform detected the following changes made outside of Terraform since the%0Alast "terraform apply" which may have affected this plan:%0A%0A  # module.lambda.local_file.lambda_code has been deleted%0A  - resource "local_file" "lambda_code" {%0A      - content              = <<-EOT%0A            // Image processing Lambda function%0A            const AWS = require('aws-sdk');%0A            const sharp = require('sharp');%0A                %0A            const s3 = new AWS.S3();%0A            const sns = new AWS.SNS();%0A                %0A            // Image sizes for resizing%0A            const sizes = [%0A              { width: 100, height: 100, suffix: 'thumbnail' },%0A              { width: 800, height: null, suffix: 'medium' },%0A              { width: 1200, height: null, suffix: 'large' }%0A            ];%0A                %0A            exports.handler = async (event) => {%0A              try {%0A                // Get the object from the event%0A                const sourceBucket = event.Records[0].s3.bucket.name;%0A                const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));%0A                    %0A                // Skip processing if the file is not in the uploads folder or not an image%0A                if (!key.startsWith('uploads/') || !key.match(/\.(jpg|jpeg|png|gif)$/i)) {%0A                  console.log('Skipping non-image file:', key);%0A                  return;%0A                }%0A                    %0A                // Get the image from S3%0A                const params = {%0A                  Bucket: sourceBucket,%0A                  Key: key%0A                };%0A                    %0A                const { Body: imageBody } = await s3.getObject(params).promise();%0A                    %0A                // Original filename without path%0A                const filename = key.split('/').pop();%0A                const fileNameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));%0A                const extension = filename.substring(filename.lastIndexOf('.') + 1);%0A                    %0A                // Process image for each size%0A                const resizePromises = sizes.map(async (size) => {%0A                  const resizedImage = await sharp(imageBody)%0A                    .resize(size.width, size.height)%0A                    .toBuffer();%0A                      %0A                  const destKey = "processed/" + fileNameWithoutExt + "-" + size.suffix + "." + extension;%0A                      %0A                  await s3.putObject({%0A                    Bucket: process.env.target_bucket,%0A                    Key: destKey,%0A                    Body: resizedImage,%0A                    ContentType: "image/" + (extension === "jpg" ? "jpeg" : extension)%0A                  }).promise();%0A                      %0A                  return destKey;%0A                });%0A                    %0A                const resizedImageKeys = await Promise.all(resizePromises);%0A                    %0A                // Send notification%0A                await sns.publish({%0A                  TopicArn: process.env.SNS_TOPIC_ARN,%0A                  Subject: 'Image Processing Completed',%0A                  Message: JSON.stringify({%0A                    originalImage: key,%0A                    processedImages: resizedImageKeys,%0A                    timestamp: new Date().toISOString()%0A                  })%0A                }).promise();%0A                    %0A                console.log('Image processing completed successfully');%0A                return {%0A                  statusCode: 200,%0A                  body: JSON.stringify({%0A                    message: 'Image processing completed successfully',%0A                    originalImage: key,%0A                    processedImages: resizedImageKeys%0A                  })%0A                };%0A                    %0A              } catch (error) {%0A                console.error('Error processing image:', error);%0A                    %0A                // Send error notification%0A                await sns.publish({%0A                  TopicArn: process.env.SNS_TOPIC_ARN,%0A                  Subject: 'Image Processing Error',%0A                  Message: JSON.stringify({%0A                    error: error.message,%0A                    stack: error.stack,%0A                    timestamp: new Date().toISOString()%0A                  })%0A                }).promise();%0A                    %0A                return {%0A                  statusCode: 500,%0A                  body: JSON.stringify({%0A                    message: 'Error processing image',%0A                    error: error.message%0A                  })%0A                };%0A              }%0A            };%0A        EOT -> null%0A        id                   = "7fa3ea14c87c4a1020900d8a22933efada1654f1"%0A        # (9 unchanged attributes hidden)%0A    }%0A%0A%0AUnless you have made equivalent changes to your configuration, or ignored the%0Arelevant attributes using ignore_changes, the following plan may include%0Aactions to undo or respond to these changes.%0A%0A─────────────────────────────────────────────────────────────────────────────%0A%0ATerraform used the selected providers to generate the following execution%0Aplan. Resource actions are indicated with the following symbols:%0A  + create%0A  ~ update in-place%0A <= read (data resources)%0A%0ATerraform will perform the following actions:%0A%0A  # module.lambda.data.archive_file.lambda_zip will be read during apply%0A  # (depends on a resource or a module with changes pending)%0A <= data "archive_file" "lambda_zip" {%0A      + id                  = (known after apply)%0A      + output_base64sha256 = (known after apply)%0A      + output_base64sha512 = (known after apply)%0A      + output_md5          = (known after apply)%0A      + output_path         = "modules/lambda/lambda_function.zip"%0A      + output_sha          = (known after apply)%0A      + output_sha256       = (known after apply)%0A      + output_sha512       = (known after apply)%0A      + output_size         = (known after apply)%0A      + type                = "zip"%0A%0A      + source {%0A          + content  = <<-EOT%0A                // Image processing Lambda function%0A                const AWS = require('aws-sdk');%0A                const sharp = require('sharp');%0A                    %0A                const s3 = new AWS.S3();%0A                const sns = new AWS.SNS();%0A                    %0A                // Image sizes for resizing%0A                const sizes = [%0A                  { width: 100, height: 100, suffix: 'thumbnail' },%0A                  { width: 800, height: null, suffix: 'medium' },%0A                  { width: 1200, height: null, suffix: 'large' }%0A                ];%0A                    %0A                exports.handler = async (event) => {%0A                  try {%0A                    // Get the object from the event%0A                    const sourceBucket = event.Records[0].s3.bucket.name;%0A                    const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));%0A                        %0A                    // Skip processing if the file is not in the uploads folder or not an image%0A                    if (!key.startsWith('uploads/') || !key.match(/\.(jpg|jpeg|png|gif)$/i)) {%0A                      console.log('Skipping non-image file:', key);%0A                      return;%0A                    }%0A                        %0A                    // Get the image from S3%0A                    const params = {%0A                      Bucket: sourceBucket,%0A                      Key: key%0A                    };%0A                        %0A                    const { Body: imageBody } = await s3.getObject(params).promise();%0A                        %0A                    // Original filename without path%0A                    const filename = key.split('/').pop();%0A                    const fileNameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));%0A                    const extension = filename.substring(filename.lastIndexOf('.') + 1);%0A                        %0A                    // Process image for each size%0A                    const resizePromises = sizes.map(async (size) => {%0A                      const resizedImage = await sharp(imageBody)%0A                        .resize(size.width, size.height)%0A                        .toBuffer();%0A                          %0A                      const destKey = "processed/" + fileNameWithoutExt + "-" + size.suffix + "." + extension;%0A                          %0A                      await s3.putObject({%0A                        Bucket: process.env.target_bucket,%0A                        Key: destKey,%0A                        Body: resizedImage,%0A                        ContentType: "image/" + (extension === "jpg" ? "jpeg" : extension)%0A                      }).promise();%0A                          %0A                      return destKey;%0A                    });%0A                        %0A                    const resizedImageKeys = await Promise.all(resizePromises);%0A                        %0A                    // Send notification%0A                    await sns.publish({%0A                      TopicArn: process.env.SNS_TOPIC_ARN,%0A                      Subject: 'Image Processing Completed',%0A                      Message: JSON.stringify({%0A                        originalImage: key,%0A                        processedImages: resizedImageKeys,%0A                        timestamp: new Date().toISOString()%0A                      })%0A                    }).promise();%0A                        %0A                    console.log('Image processing completed successfully');%0A                    return {%0A                      statusCode: 200,%0A                      body: JSON.stringify({%0A                        message: 'Image processing completed successfully',%0A                        originalImage: key,%0A                        processedImages: resizedImageKeys%0A                      })%0A                    };%0A                        %0A                  } catch (error) {%0A                    console.error('Error processing image:', error);%0A                        %0A                    // Send error notification%0A                    await sns.publish({%0A                      TopicArn: process.env.SNS_TOPIC_ARN,%0A                      Subject: 'Image Processing Error',%0A                      Message: JSON.stringify({%0A                        error: error.message,%0A                        stack: error.stack,%0A                        timestamp: new Date().toISOString()%0A                      })%0A                    }).promise();%0A                        %0A                    return {%0A                      statusCode: 500,%0A                      body: JSON.stringify({%0A                        message: 'Error processing image',%0A                        error: error.message%0A                      })%0A                    };%0A                  }%0A                };%0A            EOT%0A          + filename = "index.js"%0A        }%0A    }%0A%0A  # module.lambda.aws_lambda_function.image_processor will be updated in-place%0A  ~ resource "aws_lambda_function" "image_processor" {%0A        id                             = "img-processor-dev-image-processor-qpjdoqdo"%0A      ~ last_modified                  = "2025-06-05T13:18:47.032+0000" -> (known after apply)%0A      ~ source_code_hash               = "fEV+BBiFC8q+pevnzYvi+TwgJPat0IQVmu08lH/uZVg=" -> (known after apply)%0A        tags                           = {%0A            "Environment" = "dev"%0A            "Name"        = "img-processor-dev-image-processor-qpjdoqdo"%0A        }%0A        # (27 unchanged attributes hidden)%0A%0A        # (4 unchanged blocks hidden)%0A    }%0A%0A  # module.lambda.local_file.lambda_code will be created%0A  + resource "local_file" "lambda_code" {%0A      + content              = <<-EOT%0A            // Image processing Lambda function%0A            const AWS = require('aws-sdk');%0A            const sharp = require('sharp');%0A                %0A            const s3 = new AWS.S3();%0A            const sns = new AWS.SNS();%0A                %0A            // Image sizes for resizing%0A            const sizes = [%0A              { width: 100, height: 100, suffix: 'thumbnail' },%0A              { width: 800, height: null, suffix: 'medium' },%0A              { width: 1200, height: null, suffix: 'large' }%0A            ];%0A                %0A            exports.handler = async (event) => {%0A              try {%0A                // Get the object from the event%0A                const sourceBucket = event.Records[0].s3.bucket.name;%0A                const key = decodeURIComponent(event.Records[0].s3.object.key.replace(/\+/g, ' '));%0A                    %0A                // Skip processing if the file is not in the uploads folder or not an image%0A                if (!key.startsWith('uploads/') || !key.match(/\.(jpg|jpeg|png|gif)$/i)) {%0A                  console.log('Skipping non-image file:', key);%0A                  return;%0A                }%0A                    %0A                // Get the image from S3%0A                const params = {%0A                  Bucket: sourceBucket,%0A                  Key: key%0A                };%0A                    %0A                const { Body: imageBody } = await s3.getObject(params).promise();%0A                    %0A                // Original filename without path%0A                const filename = key.split('/').pop();%0A                const fileNameWithoutExt = filename.substring(0, filename.lastIndexOf('.'));%0A                const extension = filename.substring(filename.lastIndexOf('.') + 1);%0A                    %0A                // Process image for each size%0A                const resizePromises = sizes.map(async (size) => {%0A                  const resizedImage = await sharp(imageBody)%0A                    .resize(size.width, size.height)%0A                    .toBuffer();%0A                      %0A                  const destKey = "processed/" + fileNameWithoutExt + "-" + size.suffix + "." + extension;%0A                      %0A                  await s3.putObject({%0A                    Bucket: process.env.target_bucket,%0A                    Key: destKey,%0A                    Body: resizedImage,%0A                    ContentType: "image/" + (extension === "jpg" ? "jpeg" : extension)%0A                  }).promise();%0A                      %0A                  return destKey;%0A                });%0A                    %0A                const resizedImageKeys = await Promise.all(resizePromises);%0A                    %0A                // Send notification%0A                await sns.publish({%0A                  TopicArn: process.env.SNS_TOPIC_ARN,%0A                  Subject: 'Image Processing Completed',%0A                  Message: JSON.stringify({%0A                    originalImage: key,%0A                    processedImages: resizedImageKeys,%0A                    timestamp: new Date().toISOString()%0A                  })%0A                }).promise();%0A                    %0A                console.log('Image processing completed successfully');%0A                return {%0A                  statusCode: 200,%0A                  body: JSON.stringify({%0A                    message: 'Image processing completed successfully',%0A                    originalImage: key,%0A                    processedImages: resizedImageKeys%0A                  })%0A                };%0A                    %0A              } catch (error) {%0A                console.error('Error processing image:', error);%0A                    %0A                // Send error notification%0A                await sns.publish({%0A                  TopicArn: process.env.SNS_TOPIC_ARN,%0A                  Subject: 'Image Processing Error',%0A                  Message: JSON.stringify({%0A                    error: error.message,%0A                    stack: error.stack,%0A                    timestamp: new Date().toISOString()%0A                  })%0A                }).promise();%0A                    %0A                return {%0A                  statusCode: 500,%0A                  body: JSON.stringify({%0A                    message: 'Error processing image',%0A                    error: error.message%0A                  })%0A                };%0A              }%0A            };%0A        EOT%0A      + content_base64sha256 = (known after apply)%0A      + content_base64sha512 = (known after apply)%0A      + content_md5          = (known after apply)%0A      + content_sha1         = (known after apply)%0A      + content_sha256       = (known after apply)%0A      + content_sha512       = (known after apply)%0A      + directory_permission = "0777"%0A      + file_permission      = "0777"%0A      + filename             = "modules/lambda/src/index.js"%0A      + id                   = (known after apply)%0A    }%0A%0APlan: 1 to add, 1 to change, 0 to destroy.%0A%0A─────────────────────────────────────────────────────────────────────────────%0A%0ANote: You didn't use the -out option to save this plan, so Terraform can't%0Aguarantee to take exactly these actions if you run "terraform apply" now.%0AReleasing state lock. This may take a few moments...%0A
::debug::stderr: 
::debug::exitcode: 0
